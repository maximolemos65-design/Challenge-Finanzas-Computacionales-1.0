import streamlit as st


# -*- coding: utf-8 -*-
#Copia de Challenge Computacionales 1.0

#Automatically generated by Colab.

#Original file is located at
   # https://colab.research.google.com/drive/1PNUdvTqWbnEgkl4HFlbbBm-6bb4tTs4c

#EstadÃ­sticas bÃ¡sicas


import yfinance as yf
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
import math
from scipy.stats import skew, kurtosis
import pandas as pd
from datetime import date, timedelta

# ==========================
# 1. Preguntas al usuario
# ==========================
  
st.write("Para acciones argentinas agregar '.BA' al final del ticker. Por ejemplo: 'GGAL.BA'\n")

ticker = st.text_input("ðŸ“Œ Ingrese el ticker (ej: AAPL o GGAL.BA):", value="AAPL").strip().upper()
start_date = st.date_input("ðŸ—“ï¸ Fecha inicio", value=date.today() - timedelta(days=180))
end_date   = st.date_input("ðŸ—“ï¸ Fecha fin", value=date.today())
interval = st.selectbox(
    "ðŸ“Œ Ingrese la periodicidad:",
    ["1d", "1wk", "1mo"],   # opciones
    index=0
)
r = float(st.number_input("ðŸ“Œ Ingrese la tasa libre de riesgo (ej: 0.05 para 5%): "))
K = float(st.number_input("ðŸ“Œ Ingrese el precio strike: "))
meses = float(st.number_input("ðŸ“Œ Ingrese el tiempo al vencimiento en meses (ej: para 6 meses ingresar 6): "))
T = meses / 12
    

# --- botÃ³n ---
if st.button("Calcular"):

    # ==========================
    # 2. Descargar datos
    # ==========================
    data = yf.download(ticker, start=start_date, end=end_date, interval=interval)
    
    # Retornos logarÃ­tmicos
    data['Return'] = np.log(data['Close'] / data['Close'].shift(1))
    returns = data['Return'].dropna()
    
    # ==========================
    # 4. EstadÃ­sticas bÃ¡sicas
    # ==========================
    mean_return = returns.mean()
    std_return  = returns.std()
    
    st.write(f"\nðŸ“Š EstadÃ­sticas de {ticker}")
    st.write(f"\nâ€” ParÃ¡metros â€”")
    st.write(f"Promedio retorno: {mean_return*100:.2f}%")
    st.write(f"DesvÃ­o retorno:   {std_return*100:.2f}%")
    st.write()
    
    # ==========================
    # 5. Histograma con campana normal
    # ==========================
    plt.figure(figsize=(8,5))
    
    # Histograma en densidad
    count, bins, _ = plt.hist(returns, bins=50, density=True, edgecolor='black', alpha=0.7, label="Histograma")
    
    # Rango para la curva normal
    x = np.linspace(min(returns), max(returns), 1000)
    pdf = norm.pdf(x, mean_return, std_return)
    
    # Graficar campana normal
    plt.plot(x, pdf, 'r-', linewidth=2, label="Normal teÃ³rica")
    
    # LÃ­neas de media y desviaciones estÃ¡ndar
    plt.axvline(mean_return, color='blue', linestyle='dashed', linewidth=2, label=f"Media: {mean_return:.4f}")
    plt.axvline(mean_return + std_return, color='green', linestyle='dashed', linewidth=2, label=f"+1Ïƒ: {mean_return+std_return:.4f}")
    plt.axvline(mean_return - std_return, color='green', linestyle='dashed', linewidth=2, label=f"-1Ïƒ: {mean_return-std_return:.4f}")
    plt.axvline(mean_return + 2*std_return, color='green', linestyle='dashed', linewidth=2, label=f"+2Ïƒ: {mean_return+2*std_return:.4f}")
    plt.axvline(mean_return - 2*std_return, color='green', linestyle='dashed', linewidth=2, label=f"-2Ïƒ: {mean_return-2*std_return:.4f}")
    
    # EstÃ©tica del grÃ¡fico
    plt.title(f"DistribuciÃ³n de Retornos - {ticker}")
    plt.xlabel("Retorno logarÃ­tmico")
    plt.ylabel("Densidad")
    plt.legend()
    plt.show()
    
    # ==========================
    # 6. AsimetrÃ­a y curtosis
    # ==========================
    asimetria = skew(returns)
    curtosis_val = kurtosis(returns, fisher=False)  # fisher=True â†’ curtosis "exceso" (0 = normal)
    curtosis_total = kurtosis(returns, fisher=True)
    
    st.write("\nðŸ“Š AsimetrÃ­a y Curtosis de la serie de retornos")
    st.write(f"AsimetrÃ­a: {asimetria:.4f}")
    st.write(f"Curtosis (total): {curtosis_val:.4f}")
    st.write(f"Curtosis (exceso): {curtosis_total:.4f}")
    
    # ==========================
    # 7. Volatilidad histÃ³rica y ajuste por intervalo
    # ==========================
    if interval == "1d":
        factor = 252
        Dt = 1/252
    elif interval == "1wk":
        factor = 52
        Dt = 1/52
    elif interval == "1mo":
        factor = 12
        Dt = 1/12
    else:
        factor = 252
        Dt = 1/252
    
    vol_daily = std_return
    vol_annual = vol_daily * np.sqrt(factor)
    
    st.write(f"\nVolatilidad anualizada: {vol_annual:.5f}")
    
    # ==========================
    # 8. Black-Scholes
    # ==========================
    S = float(data['Close'].iloc[-1])  # Ãšltimo precio spot
    sigma = float(vol_annual)
    
    d1 = (math.log(S/K) + (r + 0.5*sigma**2)*T) / (sigma * math.sqrt(T))
    d2 = d1 - sigma * math.sqrt(T)
    Nd1 = norm.cdf(d1)
    Nd2 = norm.cdf(d2)
    
    st.write(f"\nâ€” Black-Scholes â€”")
    st.write(f"d1 = {d1:.4f}")
    st.write(f"d2 = {d2:.4f}")
    st.write(f"Nd1 = {Nd1:.4f}")
    st.write(f"Nd2 = {Nd2:.4f}")
    
    # ==========================
    # 9. Precios de la opciÃ³n
    # ==========================
    call_price = S * norm.cdf(d1) - K * math.exp(-r*T) * norm.cdf(d2)
    put_price  = K * math.exp(-r*T) * norm.cdf(-d2) - S * norm.cdf(-d1)
    
    # ==========================
    # 10. Valor intrÃ­nseco y extrÃ­nseco
    # ==========================
    call_intrinsic = max(S - K, 0)
    put_intrinsic  = max(K - S, 0)
    
    call_extrinsic = call_price - call_intrinsic
    put_extrinsic  = put_price - put_intrinsic
    
    st.write(f"\nðŸ’° Precio Call (BS): {call_price:.2f}")
    st.write(f"   - IntrÃ­nseco: {call_intrinsic:.2f}")
    st.write(f"   - ExtrÃ­nseco: {call_extrinsic:.2f}")
    
    st.write(f"\nðŸ’° Precio Put  (BS): {put_price:.2f}")
    st.write(f"   - IntrÃ­nseco: {put_intrinsic:.2f}")
    st.write(f"   - ExtrÃ­nseco: {put_extrinsic:.2f}")
    
    """Volatilidad"""
    
    st.write("â€” Cantidad de desvÃ­os â€”")
    
    # ==========================
    # 2.1 Calcular Z-scores
    # ==========================
    z_scores = (returns - mean_return) / std_return
    
    # Media y desvÃ­o de los Z-scores
    mean_z = z_scores.mean()
    std_z  = z_scores.std()
    
    st.write()
    st.write(f"Media z-scores: {mean_z:.6f}")
    st.write(f"DesvÃ­o z-scores: {std_z:.6f}")
    
    # ==========================
    # 2.3 Histograma de Z-Scores
    # ==========================
    plt.figure(figsize=(8,5))
    plt.hist(z_scores, bins=40, edgecolor='black', alpha=0.7, density=True, label="Z-Scores observados")
    
    # Curva normal estÃ¡ndar
    x = np.linspace(-4, 4, 200)
    plt.plot(x, norm.pdf(x, 0, 1), 'r-', lw=2, label="N(0,1) teÃ³rica")
    
    # LÃ­neas de referencia
    plt.axvline(0, color='blue', linestyle='dashed', linewidth=2, label=f"Media=0: {mean_z:.4f}")
    plt.axvline(1, color='green', linestyle='dashed', linewidth=1, label=f"+1Ïƒ: {mean_z+std_z:.4f}")
    plt.axvline(-1, color='green', linestyle='dashed', linewidth=1, label=f"-1Ïƒ: {mean_z-std_z:.4f}")
    
    # Texto con valores
    plt.text(2.5, 0.35, f"Î¼_ret = {mean_return:.5f}\nÏƒ_ret = {std_return:.5f}\nÎ¼_z = {mean_z:.5f}\nÏƒ_z = {std_z:.5f}",
             bbox=dict(facecolor='white', alpha=0.7))
    
    plt.title(f"DistribuciÃ³n de Z-Scores - {ticker}")
    plt.xlabel("Z-Score (zt)")
    plt.ylabel("Densidad")
    plt.legend()
    plt.show()
    
    # ==========================
    # 2.4 AsimetrÃ­a y curtosis de Z-Scores
    # ==========================
    asimetriaz = skew(z_scores)
    curtosisz_val = kurtosis(z_scores, fisher=False)  # fisher=True â†’ curtosis "exceso" (0 = normal)
    
    st.write("\nðŸ“Š AsimetrÃ­a y Curtosis de la serie de Z-Scores")
    st.write(f"AsimetrÃ­a: {asimetria:.4f}")
    st.write(f"Curtosis: {curtosis_val:.4f}")
    
    # ==========================
    # 2.5 Medias mÃ³viles
    # ==========================
    
    st.write("\nâ€” Volatilidad mÃ³vil â€”")
    
    # --- DesvÃ­os mÃ³viles (ventanas) calculados sobre data['Return'] para preservar Ã­ndice ---
    std_20 = data['Return'].rolling(window=20).std()    # desvÃ­o mÃ³vil 20 perÃ­odos
    std_250 = data['Return'].rolling(window=250).std()  # desvÃ­o mÃ³vil 250 perÃ­odos
    
    # Opcional: anualizar (descomentar si querÃ©s)
    std_20_ann  = std_20 * np.sqrt(factor)
    std_250_ann = std_250 * np.sqrt(factor)
    
    # --- GrÃ¡fico ---
    plt.figure(figsize=(12,6))
    plt.plot(std_20.index, std_20_ann, '--', label='Std20 (anualizada)', color='orange')
    plt.plot(std_250.index, std_250_ann, '--', label='Std250 (anualizada)', color='red')
    plt.axhline(y=vol_annual, color='green', linestyle='--', linewidth=1.5, label=f'Std constante')
    
    plt.title(f"EvoluciÃ³n del desvÃ­o estÃ¡ndar mÃ³vil de retornos - {ticker}")
    plt.xlabel("Fecha")
    plt.ylabel("DesvÃ­o estÃ¡ndar (por periodo)")
    plt.legend()
    plt.grid(alpha=0.3)
    plt.tight_layout()
    plt.show()
    
    # --- Valores recientes (por si querÃ©s ver nÃºmeros) ---
    last_std20 = std_20.dropna().iloc[-1] if std_20.dropna().size>0 else np.nan
    last_std250 = std_250.dropna().iloc[-1] if std_250.dropna().size>0 else np.nan
    # Si annualizÃ¡s, mostrar:
    st.write("\nðŸ“Š EstadÃ­sticas - Volatilidades anualizadas")
    st.write(f"Ãšltimo Std 20 (anualizado): {(last_std20*np.sqrt(factor)*100):.6f}%")
    st.write(f"Ãšltimo Std 250 (anualizado): {(last_std250*np.sqrt(factor)*100):.6f}%")
    st.write(f"Volatilidad constante del perÃ­odo (anualizada): {(vol_annual*100):.6f}%")
    
    """Value at Risk"""
    
    # ==========================
    # 14. Value at Risk (VaR empÃ­rico) + Conditional VaR con sombreado
    # ==========================
    
    import numpy as np
    import matplotlib.pyplot as plt
    
    # 1. Preguntar nivel de confianza
    conf = st.number_input(st.text_input("ðŸ“Œ Ingrese el nivel de confianza (ej: 0.95 para 95%): "))
    alpha = 1 - conf
    
    # 2. Calcular percentil empÃ­rico (VaR)
    VaR_empirico = np.percentile(returns, alpha*100)  # percentil en base a la muestra
    mean_emp = returns.mean()
    
    # 3. Filtrar retornos en la cola (<= VaR)
    cola = returns[returns <= VaR_empirico]
    
    # Suma, conteo y CVaR
    suma_cola = cola.sum()
    conteo_cola = cola.count()
    CVaR_empirico = cola.mean()
    
    st.write(f"\nðŸ”¹ Nivel de confianza (una cola, izquierda): {conf*100:.1f}%")
    st.write(f"   âž¤ VaR empÃ­rico ({alpha*100:.1f}%) = {VaR_empirico:.5f}")
    st.write(f"   âž¤ CVaR empÃ­rico (Expected Shortfall) = {CVaR_empirico:.5f}")
    st.write(f"   âž¤ Suma retornos cola = {suma_cola:.5f}")
    st.write(f"   âž¤ Conteo retornos cola = {conteo_cola}")
    
    # 4. Graficar histograma con VaR y sombreado de la cola
    plt.figure(figsize=(10,6))
    
    # Histograma completo
    counts, bins, patches = plt.hist(
        returns,
        bins=50,
        density=True,
        edgecolor='black',
        alpha=0.6,
        label="DistribuciÃ³n empÃ­rica"
    )
    
    # Sombrear las barras que estÃ¡n a la izquierda del VaR
    for patch, bin_left in zip(patches, bins[:-1]):
        if bin_left <= VaR_empirico:
            patch.set_facecolor('red')
            patch.set_alpha(0.4)
    
    # LÃ­nea en el VaR
    plt.axvline(VaR_empirico, color="red", linestyle="--", linewidth=2, label=f"VaR {conf*100:.1f}%: {VaR_empirico:.4f}")
    
    # LÃ­nea en la media
    plt.axvline(mean_emp, color="blue", linestyle="--", linewidth=2, label=f"Media: {mean_emp:.4f}")
    
    plt.title(f"VaR y CVaR empÃ­rico de {ticker} al {conf*100:.1f}% de confianza")
    plt.xlabel("Retornos")
    plt.ylabel("Densidad")
    plt.legend()
    plt.grid(alpha=0.3)
    plt.show()
    
    # 5. Mostrar resultados finales
    st.write(f"\nðŸ“Š Resultados VaR y CVaR empÃ­rico")
    st.write(f"Nivel de confianza: {conf*100:.1f}%")
    st.write(f"En el {alpha*100:.2f}% de los casos, suponiendo una distribuciÃ³n normal de los retornos y bajo condiciones normales de mercado, {ticker} tendrÃ¡ un rendimiento menor o igual a {VaR_empirico*100:.5f}%.")
    st.write(f"Â¿QuÃ© podemos esperar si se rompe el VaR? Para saberlo es Ãºtil hacer uso del VaR Condicional (CVaR), que es el promedio de los retornos mÃ¡s allÃ¡ de esa barrera. Para este caso el CVaR es {CVaR_empirico*100:.5f}%.")
    
    """SimulaciÃ³n de Montecarlo"""
    
    # ==========================
    # GrÃ¡fico combinado: histÃ³rico + Monte Carlo
    # ==========================
    
    plt.figure(figsize=(12,6))
    
    # 1. GrÃ¡fico histÃ³rico
    plt.plot(data.index, data['Close'], label=f"Precio histÃ³rico {ticker}", color="blue", linewidth=2)
    
    # 2. Determinar frecuencia segÃºn intervalo elegido
    if interval == "1d":
        freq = "B"
        N = 252
    elif interval == "1wk":
        freq = "W"
        N = 52
    elif interval == "1mo":
        freq = "M"
        N = 12
    else:
        freq = "B"
        N = 252
    
    # 3. Simulaciones Monte Carlo
    n_simulaciones = 500
    simulaciones = np.zeros((N+1, n_simulaciones))   # incluye S0
    S0 = float(data['Close'].iloc[-1])   # âœ… escalar
    mu = mean_return
    sigma = std_return
    dt = Dt   # ya lo definiste segÃºn intervalo
    
    for j in range(n_simulaciones):
        prices = [S0]
        for t in range(1, N+1):
            z = np.random.normal()
            St = float(prices[-1] * np.exp((mu - 0.5 * sigma**2)*dt + sigma*np.sqrt(dt)*z))  # âœ… float
            prices.append(St)
        simulaciones[:, j] = np.array(prices).flatten()   # âœ… vector 1D
    
        # Fechas futuras (arranca despuÃ©s del Ãºltimo dato real)
        future_dates = pd.date_range(start=data.index[-1], periods=N+1, freq=freq)[1:]
        plt.plot(future_dates, prices[1:], linewidth=1, alpha=0.2, color="orange")
    
    # 4. LÃ­nea promedio de todas las simulaciones
    mean_path = simulaciones.mean(axis=1)[1:]
    plt.plot(future_dates, mean_path, color="black", linewidth=2, label="Media de simulaciones")
    
    # 5. Ãšltimo precio como referencia
    plt.scatter(data.index[-1], S0, color="black", zorder=5, label=f"Ãšltimo precio: {S0:.2f}")
    
    # 6. Strike
    plt.axhline(y=K, color="red", linestyle="--", linewidth=1.5, label=f"Strike = {K}")
    
    # 7. Formato
    plt.title(f"Trayectoria histÃ³rica y simulaciones Monte Carlo - {ticker}")
    plt.xlabel("Fecha")
    plt.ylabel("Precio")
    plt.legend()
    plt.grid(alpha=0.3)
    plt.show()
    
    # ==========================
    # 8. Histograma de precios finales
    # ==========================
    final_prices = simulaciones[-1, :]  # Ãºltimos precios de cada simulaciÃ³n
    
    plt.figure(figsize=(8,5))
    plt.hist(final_prices, bins=10, edgecolor='black', alpha=0.7)
    
    # LÃ­nea en el precio inicial
    plt.axvline(S0, color="blue", linestyle="--", linewidth=2, label=f"Precio inicial: {S0:.2f}")
    
    # LÃ­nea en el strike
    plt.axvline(K, color="red", linestyle="--", linewidth=2, label=f"Strike = {K}")
    
    # EstadÃ­sticas
    mean_final = np.mean(final_prices)
    std_final  = np.std(final_prices)
    
    st.write()
    plt.axvline(mean_final, color="green", linestyle="--", linewidth=2, label=f"Media final: {mean_final:.2f}")
    plt.title(f"DistribuciÃ³n de precios finales - Monte Carlo ({ticker})")
    plt.xlabel("Precio al vencimiento (1 aÃ±o)")
    plt.ylabel("Frecuencia")
    plt.legend()
    plt.show()
    
    st.write("\nðŸ“Š Resultados Monte Carlo")
    st.write(f"Precio inicial: {S0:.2f}")
    st.write(f"Precio medio simulado a 1 aÃ±o: {mean_final:.2f}")
    st.write(f"DesvÃ­o de precios finales: {std_final:.2f}")
    
    """VI"""
    
    # ==========================
    # 15. Volatilidad implÃ­cita
    # ==========================
    
    from scipy.optimize import brentq  # bÃºsqueda de raÃ­ces
    
    # ==========================
    # 1. Volatilidad ImplÃ­cita (varios strikes)
    # ==========================
    
    n_opciones = int(st.number_input("ðŸ“Œ Â¿CuÃ¡ntas opciones desea ingresar? "))
    
    resultados = []
    
    for i in range(n_opciones):
        st.write(f"\n--- OpciÃ³n {i+1} ---")
        K_st.text_input = float(st.text_input("ðŸ‘‰ Strike de la opciÃ³n: "))
        precio_opcion = float(st.text_input("ðŸ‘‰ Precio de mercado de la opciÃ³n: "))
        tipo = st.text_input("ðŸ‘‰ Tipo de opciÃ³n (C para Call / P para Put): ").upper()
    
        # FunciÃ³n de Black-Scholes
        def black_scholes(S, K, T, r, sigma, tipo="C"):
            d1 = (math.log(S/K) + (r + 0.5*sigma**2)*T) / (sigma * math.sqrt(T))
            d2 = d1 - sigma * math.sqrt(T)
            if tipo == "C":
                return S * norm.cdf(d1) - K * math.exp(-r*T) * norm.cdf(d2)
            else:
                return K * math.exp(-r*T) * norm.cdf(-d2) - S * norm.cdf(-d1)
    
        # FunciÃ³n objetivo
        def objective(sigma):
            return black_scholes(S, K_st.text_input, T, r, sigma, tipo) - precio_opcion
    
        try:
            iv = brentq(objective, 1e-6, 5)  # rango: 0.01% a 500% anual
            resultados.append((K_st.text_input, tipo, precio_opcion, iv))
            st.write(f"âœ… Strike {K_st.text_input:.2f}, {tipo}: IV â‰ˆ {iv*100:.2f}%")
        except ValueError:
            st.write(f"âš ï¸ No se pudo encontrar IV para Strike {K_st.text_input:.2f}")
    
    # ==========================
    # Mostrar tabla final
    # ==========================
    st.write("\nðŸ“Š Resultados de Volatilidad ImplÃ­cita")
    for K_st.text_input, tipo, precio, iv in resultados:
        st.write(f"Strike {K_st.text_input:.2f} | {tipo} | Precio {precio:.2f} | IV â‰ˆ {iv*100:.2f}%")
    
    # ==========================
    # GrÃ¡fico: Sonrisa de Volatilidad
    # ==========================
    if len(resultados) > 0:
        strikes = [r[0] for r in resultados]
        ivs = [r[3] for r in resultados]
    
        plt.figure(figsize=(8,5))
        plt.plot(strikes, [iv*100 for iv in ivs], marker="o", linestyle="-", color="purple")
        plt.title(f"Sonrisa de Volatilidad ImplÃ­cita - {ticker}")
        plt.xlabel("Strike")
        plt.ylabel("Volatilidad ImplÃ­cita (%)")
        plt.grid(alpha=0.3)
        plt.show()
    
    """Volumen"""
    
    # ==========================
    # 1. Preparar datos
    # ==========================
    # returns ya lo tenÃ©s calculado antes
    # Calcular cambio porcentual en volumen
    volumen = data['Volume'].squeeze()   # para que sea Serie
    vol_change = volumen.pct_change()
    
    # Combinar en un DataFrame
    df_aux = pd.DataFrame({
        "Return": returns,
        "Vol_Change": vol_change
    }).dropna()
    
    # ==========================
    # 2. GrÃ¡fico de dispersiÃ³n
    # ==========================
    plt.figure(figsize=(8,5))
    plt.scatter(df_aux['Return'], df_aux['Vol_Change'], alpha=0.5, color="purple")
    plt.title(f"RelaciÃ³n entre Retornos y Cambio en Volumen - {ticker}")
    plt.xlabel("Retornos")
    plt.ylabel("Cambio en Volumen (%)")
    plt.grid(alpha=0.3)
    plt.show()
    
    # ==========================
    # 3. CorrelaciÃ³n explÃ­cita
    # ==========================
    correlacion = df_aux['Return'].corr(df_aux['Vol_Change'])
    st.write(f"\nðŸ“Š CorrelaciÃ³n Retornos vs Cambio en Volumen: {correlacion:.4f}")
    
    
    # ==========================
    # 4. EstadÃ­sticas
    # ==========================
    vol_media  = volumen.mean()
    vol_desvio = volumen.std()
    vol_max    = volumen.max()
    vol_min    = volumen.min()
    
    st.write(f"\nðŸ“Š MÃ©tricas de volumen para {ticker}")
    st.write(f"Promedio : {vol_media:,.0f}")
    st.write(f"DesvÃ­o   : {vol_desvio:,.0f}")
    st.write(f"MÃ¡ximo   : {vol_max:,.0f}")
    st.write(f"MÃ­nimo   : {vol_min:,.0f}")
    
    # ==========================
    # 5. GrÃ¡fico de barras de Volumen
    # ==========================
    plt.figure(figsize=(12, 6))
    plt.bar(volumen.index, volumen.values, width=1, color='purple', alpha=0.7)
    plt.title(f"Volumen de negociaciÃ³n a lo largo del tiempo - {ticker}")
    plt.xlabel("Fecha")
    plt.ylabel("Volumen")
    plt.grid(axis='y', alpha=0.5)
    plt.xticks(volumen.index[::len(volumen)//10], rotation=45) # Set x-axis ticks to a subset of dates
    plt.tight_layout() # Adjust layout to prevent labels overlapping
    plt.show()
    
    """Sugerencia de estrategia"""
    
    # tipo de estrategia
    # tendencia
    # volatilidad
    
    """Momentum - Variaciones"""
    
    import numpy as np
    import pandas as pd
    
    # Create a new DataFrame for the momentum variations
    momentum_data = pd.DataFrame(index=data.index)
    
    # Paso 1: clasificar retorno actual y agregar a momentum_data
    condiciones = [
        data['Return'] > 0,
        data['Return'] < 0,
        data['Return'] == 0
    ]
    valores = ['Positivo', 'Negativo', 'Sin variaciÃ³n']
    momentum_data['Return_class'] = np.select(condiciones, valores, default='Sin variaciÃ³n')
    
    # Paso 2: clasificaciÃ³n del retorno anterior y agregar a momentum_data
    momentum_data['Return_lag1'] = momentum_data['Return_class'].shift(1)
    momentum_data['Return_lag1'] = momentum_data['Return_lag1'].fillna('Sin dato previo')
    
    # Paso 3: retornos de dÃ­as previos y agregar a momentum_data
    momentum_data['Return_lag2'] = momentum_data['Return_class'].shift(2)
    momentum_data['Return_lag2'] = momentum_data['Return_lag2'].fillna('Sin dato previo')
    momentum_data['Return_lag3'] = momentum_data['Return_class'].shift(3)
    momentum_data['Return_lag3'] = momentum_data['Return_lag3'].fillna('Sin dato previo')
    momentum_data['Return_lag4'] = momentum_data['Return_class'].shift(4)
    momentum_data['Return_lag4'] = momentum_data['Return_lag4'].fillna('Sin dato previo')
    
    # ------------------------------------------------------------------------LAG1-----------------------------------------------------------------------------------------------
    
    # Filter momentum_data where 'Return_class' is 'Positivo'
    filtered_momentum_data_positivo = momentum_data[momentum_data['Return_class'] == 'Positivo']
    
    # Count positive and negative values in Return_lag1 for the filtered data (Positivo)
    count_pp = filtered_momentum_data_positivo['Return_lag1'].value_counts().get('Positivo', 0)
    count_pn = filtered_momentum_data_positivo['Return_lag1'].value_counts().get('Negativo', 0)
    count_svarp1 = filtered_momentum_data_positivo['Return_lag1'].value_counts().get('Sin variaciÃ³n', 0)
    total_lag1_positivo = count_pp + count_pn + count_svarp1
    prob_pp = count_pp / total_lag1_positivo
    prob_pn = count_pn / total_lag1_positivo
    
    st.write(f"Probabilidad positivo-positivo: {prob_pp*100:.2f}%")
    st.write(f"Probabilidad positivo-negativo: {prob_pn*100:.2f}%")
    
    # Filter momentum_data where 'Return_class' is 'Negativo'
    filtered_momentum_data_negativo = momentum_data[momentum_data['Return_class'] == 'Negativo']
    
    # Count positive and negative values in Return_lag1 for the filtered data (Negativo)
    count_np = filtered_momentum_data_negativo['Return_lag1'].value_counts().get('Positivo', 0)
    count_nn = filtered_momentum_data_negativo['Return_lag1'].value_counts().get('Negativo', 0)
    count_svarn1 = filtered_momentum_data_negativo['Return_lag1'].value_counts().get('Sin variaciÃ³n', 0)
    total_lag1_negativo = count_np + count_nn + count_svarn1
    prob_nn = count_nn / total_lag1_negativo
    prob_np = count_np / total_lag1_negativo
    
    st.write(f"Probabilidad negativo-negativo: {prob_nn*100:.2f}%")
    st.write(f"Probabilidad negativo-positivo: {prob_np*100:.2f}%")
    
    # ------------------------------------------------------------------------LAG2-----------------------------------------------------------------------------------------------
    
    # Filter momentum_data where 'Return_class' and 'Return_lag1' are 'Positivo'
    filtered_momentum_data_pp = momentum_data[(momentum_data['Return_class'] == 'Positivo') & (momentum_data['Return_lag1'] == 'Positivo')]
    
    # Count positive and negative values in Return_lag2 for the filtered data (Positivo, Positivo)
    count_ppp = filtered_momentum_data_pp['Return_lag2'].value_counts().get('Positivo', 0)
    count_ppn = filtered_momentum_data_pp['Return_lag2'].value_counts().get('Negativo', 0)
    count_svarpp2 = filtered_momentum_data_pp['Return_lag2'].value_counts().get('Sin variaciÃ³n', 0)
    total_lag2_positivo = count_ppp + count_ppn + count_svarpp2
    prob_ppp = count_ppp / total_lag2_positivo
    prob_ppn = count_ppn / total_lag2_positivo
    
    st.write(f"Probabilidad positivo-positivo-positivo: {prob_ppp*100:.2f}%")
    st.write(f"Probabilidad positivo-positivo-negativo: {prob_ppn*100:.2f}%")
    
    # Filter momentum_data where 'Return_class' and 'Return_lag1' are 'Negativo'
    filtered_momentum_data_nn = momentum_data[(momentum_data['Return_class'] == 'Negativo') & (momentum_data['Return_lag1'] == 'Negativo')]
    
    # Count positive and negative values in Return_lag1 for the filtered data (Negativo)
    count_nnp = filtered_momentum_data_nn['Return_lag2'].value_counts().get('Positivo', 0)
    count_nnn = filtered_momentum_data_nn['Return_lag2'].value_counts().get('Negativo', 0)
    count_svarnn2 = filtered_momentum_data_nn['Return_lag2'].value_counts().get('Sin variaciÃ³n', 0)
    total_lag2_negativo = count_nnp + count_nnn + count_svarnn2
    prob_nnp = count_nnp / total_lag2_negativo
    prob_nnn = count_nnn / total_lag2_negativo
    
    st.write(f"Probabilidad negativo-negativo-positivo: {prob_nnp*100:.2f}%")
    st.write(f"Probabilidad negativo-negativo-negativo: {prob_nnn*100:.2f}%")
    
    # ------------------------------------------------------------------------LAG3-----------------------------------------------------------------------------------------------
    
    # Filter momentum_data where 'Return_class' and 'Return_lag1' are 'Positivo'
    filtered_momentum_data_ppp = momentum_data[(momentum_data['Return_class'] == 'Positivo') & (momentum_data['Return_lag1'] == 'Positivo') & (momentum_data['Return_lag2'] == 'Positivo')]
    
    # Count positive and negative values in Return_lag2 for the filtered data (Positivo, Positivo)
    count_pppp = filtered_momentum_data_ppp['Return_lag3'].value_counts().get('Positivo', 0)
    count_pppn = filtered_momentum_data_ppp['Return_lag3'].value_counts().get('Negativo', 0)
    count_svarpp3 = filtered_momentum_data_ppp['Return_lag3'].value_counts().get('Sin variaciÃ³n', 0)
    total_lag3_positivo = count_pppp + count_pppn + count_svarpp3
    prob_pppp = count_pppp / total_lag3_positivo
    prob_pppn = count_pppn / total_lag3_positivo
    
    st.write(f"Probabilidad positivo-positivo-positivo-positivo: {prob_pppp*100:.2f}%")
    st.write(f"Probabilidad positivo-positivo-positivo-negativo: {prob_pppn*100:.2f}%")
    
    # Filter momentum_data where 'Return_class' and 'Return_lag1' are 'Negativo'
    filtered_momentum_data_nnn = momentum_data[(momentum_data['Return_class'] == 'Negativo') & (momentum_data['Return_lag1'] == 'Negativo') & (momentum_data['Return_lag2'] == 'Negativo')]
    
    # Count positive and negative values in Return_lag1 for the filtered data (Negativo)
    count_nnnp = filtered_momentum_data_nnn['Return_lag3'].value_counts().get('Positivo', 0)
    count_nnnn = filtered_momentum_data_nnn['Return_lag3'].value_counts().get('Negativo', 0)
    count_svarnn3 = filtered_momentum_data_nnn['Return_lag3'].value_counts().get('Sin variaciÃ³n', 0)
    total_lag3_negativo = count_nnnp + count_nnnn + count_svarnn3
    prob_nnnp = count_nnnp / total_lag3_negativo
    prob_nnnn = count_nnnn / total_lag3_negativo
    
    st.write(f"Probabilidad negativo-negativo-negativo-positivo: {prob_nnnp*100:.2f}%")
    st.write(f"Probabilidad negativo-negativo-negativo-negativo: {prob_nnnn*100:.2f}%")
    
    # ------------------------------------------------------------------------LAG4-----------------------------------------------------------------------------------------------
    
    # Filter momentum_data where 'Return_class' and 'Return_lag1' are 'Positivo'
    filtered_momentum_data_pppp = momentum_data[(momentum_data['Return_class'] == 'Positivo') & (momentum_data['Return_lag1'] == 'Positivo') & (momentum_data['Return_lag2'] == 'Positivo') & (momentum_data['Return_lag3'] == 'Positivo')]
    
    # Count positive and negative values in Return_lag2 for the filtered data (Positivo, Positivo)
    count_ppppp = filtered_momentum_data_pppp['Return_lag4'].value_counts().get('Positivo', 0)
    count_ppppn = filtered_momentum_data_pppp['Return_lag4'].value_counts().get('Negativo', 0)
    count_svarppp3 = filtered_momentum_data_pppp['Return_lag4'].value_counts().get('Sin variaciÃ³n', 0)
    total_lag4_positivo = count_ppppp + count_ppppn + count_svarppp3
    prob_ppppp = count_ppppp / total_lag4_positivo
    prob_ppppn = count_ppppn / total_lag4_positivo
    
    st.write(f"Probabilidad positivo-positivo-positivo-positivo-positivo: {prob_ppppp*100:.2f}%")
    st.write(f"Probabilidad positivo-positivo-positivo-positivo-negativo: {prob_ppppn*100:.2f}%")
    
    # Filter momentum_data where 'Return_class' and 'Return_lag1' are 'Negativo'
    filtered_momentum_data_nnnn = momentum_data[(momentum_data['Return_class'] == 'Negativo') & (momentum_data['Return_lag1'] == 'Negativo') & (momentum_data['Return_lag2'] == 'Negativo') & (momentum_data['Return_lag3'] == 'Negativo')]
    
    # Count positive and negative values in Return_lag1 for the filtered data (Negativo)
    count_nnnnp = filtered_momentum_data_nn['Return_lag4'].value_counts().get('Positivo', 0)
    count_nnnnn = filtered_momentum_data_nn['Return_lag4'].value_counts().get('Negativo', 0)
    count_svarnnn3 = filtered_momentum_data_nn['Return_lag4'].value_counts().get('Sin variaciÃ³n', 0)
    total_lag4_negativo = count_nnnnp + count_nnnnn + count_svarnnn3
    prob_nnnnp = count_nnnnp / total_lag4_negativo
    prob_nnnnn = count_nnnnn / total_lag4_negativo
    
    st.write(f"Probabilidad negativo-negativo-negativo-negativo-positivo: {prob_nnnnp*100:.2f}%")
    st.write(f"Probabilidad negativo-negativo-negativo-negativo-negativo: {prob_nnnnn*100:.2f}%")
    
    momentum_data
    
    # ideas posibles
    # montecarlo OK
    # VaR OK
    # volatilidad implicita poniendo una base y su precio YA FUE PQ NO TENEMOS EN CUENTA DIVIDENDOS DIFIERE CON TRADINGVIEW
    # grafico de serie de precio OK
    # hacerlo mas interactivo (consultarle al usuario si le gustaria ver tal informaciÃ³n, consultarle si quisiera mÃ¡s explicaciÃ³n sobre un concepto)
    # curtosis y asimetria OK
    # analisis de volumen? AGREGAR GRAFICO DE BARRAS
    # planillas?No creo, a lo sumo letras griegas
    # flourish ver por graficos dinamicos
